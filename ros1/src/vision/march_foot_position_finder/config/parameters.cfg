#!/usr/bin/env python
PACKAGE = "march_foot_position_finder"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()
# A dynamic reconfigurable parameter can be added by:
#   gen.add(str: param_name, type, level, str: description, value, lower_bound, upper_bound)
#   More info, see: http://wiki.ros.org/dynamic_reconfigure/Tutorials/HowToWriteYourFirstCfgFile


preprocessor = gen.add_group("Preprocessor", type="collapse", state=True)
preprocessor.add("voxel_size", double_t, 0, "Cell size used for voxel downsampling", 0.01, 0.001, 0.50)
preprocessor.add("x_min", double_t, 0, "Minimum x boundary for filtering points", -1.3, -2, 2)
preprocessor.add("x_max", double_t, 0, "Maximum x boundary for filtering points", 1.3, -2, 2)
preprocessor.add("y_min", double_t, 0, "Minimum y boundary for filtering points", -1.3, -2, 2)
preprocessor.add("y_max", double_t, 0, "Maximum y boundary for filtering points", 1.3, -2, 2)
preprocessor.add("z_min", double_t, 0, "Minimum z boundary for filtering points", 0, -2, 2)
preprocessor.add("z_max", double_t, 0, "Maximum z boundary for filtering points", 1, -2, 2)

foot_position_finder = gen.add_group("FootPositionFinder", type="collapse", state=True)
foot_position_finder.add("physical_cameras", bool_t, 0, "Whether to use physical realsense cameras", False)
foot_position_finder.add("base_frame", str_t, 0, "The frame in which computations are done", "world")

foot_position_finder.add("foot_gap", double_t, 0, "Horizontal distance between the two feet", 0.25, 0, 0.5)
foot_position_finder.add("step_distance", double_t, 0, "Step size", 0.30, 0, 1)

foot_position_finder.add("outlier_distance", double_t, 0, "Distance metric used to classify points as outliers", 0.05, 0.001, 0.75)
foot_position_finder.add("sample_size", int_t, 0, "Number of points used for temporal averages", 3, 1, 20)
foot_position_finder.add("height_zero_threshold", double_t, 0, "Threshold for point heights to be non zero", 0.02, 0, 0.20)

point_finder = gen.add_group("PointFinder", type="collapse", state=True)
point_finder.add("foot_width", double_t, 0, "Width of the rectangle used to find foot positions", 0.10, 0.05, 0.20)
point_finder.add("foot_length", double_t, 0, "Length of the rectangle used to find foot positions", 0.20, 0.10, 0.40)

point_finder.add("derivative_threshold", double_t, 0, "Maximum allowed second derivative values", 0.02, 0.001, 0.20)
point_finder.add("available_points_ratio", double_t, 0, "Ratio of points that should gave a derivative lower than the threshold", 0.90, 0.50, 1.0)
point_finder.add("max_z_distance", double_t, 0, "Maximum allowed height difference between two steps", 0.25, 0.05, 0.50)
point_finder.add("num_track_points", int_t, 0, "Number of points in the point track between start and end positions", 30, 5, 100)

point_finder.add("x_displacements_outside", double_t, 0, "Distance the algorithm looks left of the optimal point", 0.05, 0.01, 0.50)
point_finder.add("x_displacements_inside", double_t, 0, "Distance the algorithm looks right of the optimal point", 0.10, 0.01, 0.50)
point_finder.add("y_displacements_near", double_t, 0, "Distance the algorithm looks in front of the optimal point", 0.25, 0.01, 0.50)
point_finder.add("y_displacements_far", double_t, 0, "Distance the algorithm looks behind the optimal point", 0.10, 0.01, 0.50)

exit(gen.generate(PACKAGE, "march_foot_position_finder", "parameters"))
