variables:
  # Define how submodules are handled. See https://docs.gitlab.com/ee/ci/runners/README.html#git-submodule-strategy
  GIT_SUBMODULE_STRATEGY: recursive
  ROS1_DOCKERFILE: ".gitlab/images/Dockerfile_noetic"
  ROS2_DOCKERFILE: ".gitlab/images/Dockerfile_foxy"
  FLAKE8_DOCKERFILE: ".gitlab/images/Dockerfile_flake8"
  CLANG_FORMAT_DOCKERFILE: ".gitlab/images/Dockerfile_clang_format"

# The different stages of the pipeline. They will occur in this order.
# See https://docs.gitlab.com/ee/ci/yaml/README.html#stages for more explaination
# on how this should be interpreted.
stages:
  - Build container
  - Lint code
  - Build code
  - Test code
  - Static analysis on code

# GitLab defines different job types, depending on how the job is scheduled.
# Right now, we use two types: 1) branches and 2) merge_requests.
#
# 1) Branches
# Pipelines labeled "branches" are executed on the latest commit of a branch. All
# jobs that are scheduled conditionally based on the file changes in the
# latest commit (the "changes" keyword,
# see https://docs.gitlab.com/ee/ci/yaml/README.html#onlychangesexceptchanges)
#
# 2) Merge requests
# Pipelines labeled "merge_requests" are executed when commits are pushed to a
# merge request. This pipeline runs on the difference between the target branch
# and the source branch. The "changes" keywords covers ALL changes that differ
# between the two branches.
#
# In short: branches        = only latest commit
#           merge_requests  = all commits in in merge request
#
# An overview of all the different types can be
# found on https://docs.gitlab.com/ee/ci/yaml/README.html#onlyexcept-basic

# This is a "hidden" stage that is not run by itself. It is run extended by other
# stages that define different values for the variables. This avoids duplication.
.container_builder:
  stage: Build container
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  before_script:
    - mkdir -p /kaniko/.docker
    # Equivalent to `docker login` but without installing docker"
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" > /kaniko/.docker/config.json
  script:
    # The kaniko executor from https://github.com/GoogleContainerTools/kaniko
    # Information about all the parameters can be found there.
      - /kaniko/executor --cache=$CACHE --dockerfile $CI_PROJECT_DIR/$DOCKER_FILE --destination $REGISTRY_IMAGE:$TAG --cleanup
  rules:
    # These rules act as a sort of XOR for MR pipelines and branch pipelines.
    # As described on https://docs.gitlab.com/ee/ci/yaml/#switch-between-branch-pipelines-and-merge-request-pipelines
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - $DOCKER_FILE
      variables:
        TAG: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'
      when: never
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - $DOCKER_FILE
      variables:
        TAG: $CI_COMMIT_BRANCH

.ros_container_builder:
  rules:
    # These rules act as a sort of XOR for MR pipelines and branch pipelines.
    # As described on https://docs.gitlab.com/ee/ci/yaml/#switch-between-branch-pipelines-and-merge-request-pipelines
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - $DOCKER_FILE
        - "$ROS_VERSION/**/package.xml"
      variables:
        TAG: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'
      when: never
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - $DOCKER_FILE
        - "$ROS_VERSION/**/package.xml"
      variables:
        TAG: $CI_COMMIT_BRANCH
  extends:
    - .container_builder


# Build the container iff the Dockerfile has been changed. This only runs for
# branches because this is a very long job. Running it for merge requests would
# mean that this job is scheduled every time that a commit is pushed in a merge requests,
# which is unnessecary if the Dockerfile is only changed once in the merge request.
ROS1 container build:
  variables:
    CACHE: "true"
    ROS_VERSION: "ros1"
    DOCKER_FILE: $ROS1_DOCKERFILE
    REGISTRY_IMAGE: "$CI_REGISTRY_IMAGE/noetic"
  extends:
    - .ros_container_builder

ROS2 container build:
  variables:
    CACHE: "true"
    ROS_VERSION: "ros2"
    DOCKER_FILE: $ROS2_DOCKERFILE
    REGISTRY_IMAGE: "$CI_REGISTRY_IMAGE/foxy"
  extends:
    - .ros_container_builder

flake8 container build:
  variables:
    CACHE: "false"
    DOCKER_FILE: $FLAKE8_DOCKERFILE
    REGISTRY_IMAGE: "$CI_REGISTRY_IMAGE/flake8"
  extends:
    - .container_builder

clang_format container build:
  variables:
    CACHE: "false"
    DOCKER_FILE: $CLANG_FORMAT_DOCKERFILE
    REGISTRY_IMAGE: "$CI_REGISTRY_IMAGE/clang_format"
  extends:
    - .container_builder

#################
# flake8 linter #
#################
# Runs a Python linter on the code to see if the code style is consistent and
# to avoid common mistakes
flake8:
  stage: Lint code
  image: $CI_REGISTRY_IMAGE/flake8:$TAG
  variables:
      DOCKER_FILE: $FLAKE8_DOCKERFILE
  script:
    # Return the return value of the rightmost failed command. It is unlikely that `sed` fails, but
    # the if the flake8 runner fails then everything is propagated through. This means that the
    # return value of the whole pipe sequence will be the same as the return value of
    # the flake8 command.
    - set -o pipefail
    # The codeclimate format returns violations on new lines, but GitLab expects a json
    # array. This adds the required "[", "]" and ","s for the file to be interpreted as
    # a valid JSON array.
    - python3 -m flake8 --format=codeclimate --config .flake8 | sed '1s;^;[;' | sed 's/$/,/g' | sed '$ s/.$//' | sed '$ a ]' | tee codeclimate.json
    # If the above statement succeeds, then codeclimate.json will be empty. We add an empty
    # array to ensure that the codeclimate.json file still has a valid json syntax
    - echo "[]" | tee codeclimate.json
  artifacts:
    reports:
      codequality: codeclimate.json
  needs:
    - job: "flake8 container build"
      optional: true
  rules:
    # These rules are here to select a different Docker image depending on the
    # running conditions. The statements are evaluated from top to bottom until a rule
    # is matched.
    # They can be interpreted as:
    #   1. Run if the pipeline is a MR and the Dockerfile has changed with the image
    #      created from the changed Dockerfile.
    #   2. Don't run if the pipeline is both a branch and in a merge request
    #      This is to avoid duplicate pipelines where both a MR pipeline and a branch pipeline
    #      is scheduled.
    #   3. Run if the pipline is for a branch without a MR and the Dockerfile has changed
    #      with the image created from the changed Dockerfile.
    #   4. In all other cases, if a flake8 or Python related file has changed run with
    #      the image from the Dockerfile in `main`.
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - $DOCKER_FILE
      variables:
        TAG: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'
      when: never
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - $DOCKER_FILE
      variables:
        TAG: $CI_COMMIT_BRANCH
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_COMMIT_BRANCH'
      changes:
        - ".flake8"
        - "**/*.py"
      variables:
        TAG: $CI_DEFAULT_BRANCH

#######################
# clang-format linter #
#######################
# Check if the C++ code is consistent in code formatting (correct amount of tabs/spaces,
# correct indentation etc.)
clang-format:
  stage: Lint code
  image: $CI_REGISTRY_IMAGE/clang_format:$TAG
  variables:
      DOCKER_FILE: $CLANG_FORMAT_DOCKERFILE
  script:
    - run-clang-format.py -r ros1/src ros2/src --style=file
  needs:
    - job: "clang_format container build"
      optional: true
  rules:
    # These rules are here to select a different Docker image depending on the
    # running conditions. The statements are evaluated from top to bottom until a rule
    # is matched.
    # They can be interpreted as:
    #   1. Run if the pipeline is a MR and the Dockerfile has changed with the image
    #      created from the changed Dockerfile.
    #   2. Don't run if the pipeline is both a branch and in a merge request
    #      This is to avoid duplicate pipelines where both a MR pipeline and a branch pipeline
    #      is scheduled.
    #   3. Run if the pipline is for a branch without a MR and the Dockerfile has changed
    #      with the image created from the changed Dockerfile.
    #   4. In all other cases, if a clang_format, C or C++ related file has changed run with
    #      the image from the Dockerfile in `main`.
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - $DOCKER_FILE
      variables:
        TAG: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'
      when: never
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - $DOCKER_FILE
      variables:
        TAG: $CI_COMMIT_BRANCH
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_COMMIT_BRANCH'
      changes:
        - "ros1/src/**/*.{c,h,C,H,cpp,hpp,cc,hh,c++,h++,cxx,hxx}"
        - "ros2/src/**/*.{c,h,C,H,cpp,hpp,cc,hh,c++,h++,cxx,hxx}"
        - ".clang-format"
        - ".clang-format-ignore"
      variables:
        TAG: $CI_DEFAULT_BRANCH

####################
# Build code stage #
####################
# Run the build command to see if everything compiles without errors. This is a
# separate stage for the noetic and for the foxy code, because they are not dependent
# on each other and can therefore be run in parallel.
# Besides compiling, this also produces a "compile_commands.json" file that is used
# by subsequent C++ static analysis stages.

# The following two hidden jobs are used to reduce duplication because these rules are
# almost the same for a lot of subsequent jobs. They only vary in a few ways, which is why
# some variables are introduced. The following three variables change, depending on the
# version of ROS:
#   1. ROS_VERSION, either 'ros1' or 'ros2'
#   2. ROS_CODENAME, either 'noetic' or 'foxy'
#   3. DOCKER_FILE, the path of the Dockerfile that defines the execution environment. This
#      points to a ROS1 and ROS2 specific Dockerfile
.only_on_ros_changes:
  image: $CI_REGISTRY_IMAGE/$ROS_CODENAME:$TAG
  rules:
    # These rules are here to select a different Docker image depending on the
    # running conditions. The statements are evaluated from top to bottom until a rule
    # is matched.
    # They can be interpreted as:
    #   1. Run if the pipeline is a MR and the Dockerfile has changed with the image
    #      created from the changed Dockerfile.
    #   2. Don't run if the pipeline is both a branch and in a merge request
    #      This is to avoid duplicate pipelines where both a MR pipeline and a branch pipeline
    #      is scheduled.
    #   3. Run if the pipline is for a branch without a MR and the Dockerfile has changed
    #      with the image created from the changed Dockerfile.
    #   4. In all other cases, if a ROS or clang-tidy related file has changed run with
    #      the image from the Dockerfile in `main`.
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - $DOCKER_FILE
      variables:
        TAG: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'
      when: never
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - $DOCKER_FILE
      variables:
        TAG: $CI_COMMIT_BRANCH
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_COMMIT_BRANCH'
      changes:
        - "$ROS_VERSION/**/*"
        - ".clang-tidy"
      variables:
        TAG: $CI_DEFAULT_BRANCH

# Define the values of the ROS1 and ROS2 specific instances of
# the ".only_on_ros_changes" job
.only_on_ros1_changes:
  variables:
    ROS_VERSION: "ros1"
    ROS_CODENAME: "noetic"
    DOCKER_FILE: $ROS1_DOCKERFILE
  needs:
    - job: "ROS1 container build"
      optional: true
  extends:
    - .only_on_ros_changes

.only_on_ros2_changes:
  variables:
    ROS_VERSION: "ros2"
    ROS_CODENAME: "foxy"
    DOCKER_FILE: $ROS2_DOCKERFILE
  needs:
    - job: "ROS2 container build"
      optional: true
  extends:
    - .only_on_ros_changes

# A generic ROS builder that can run either for ROS1 or ROS2, depending on the given variables
# $ROS_VERSION and $ROS_CODENAME
.base_builder:
  stage: Build code
  artifacts:
    paths:
      - $ROS_VERSION/build/
      - $ROS_VERSION/install/
      - $ROS_VERSION/log/
  script:
    - cd $ROS_VERSION/
    - source /opt/ros/$ROS_CODENAME/local_setup.bash && colcon build --cmake-args "-DCMAKE_EXPORT_COMPILE_COMMANDS=1" --event-handlers console_direct+

# Define the two actual jobs that are created from both the ROS version specific variables AND
# the generic base builder.
noetic:build:
  extends:
    - .only_on_ros1_changes
    - .base_builder

foxy:build:
  extends:
    - .only_on_ros2_changes
    - .base_builder

###################
# Test code stage #
###################
# Run the tests, both for noetic and foxy. These stages are separated because they
# are not dependent on eachother. This enables extra parallelization.
.base_tester:
  stage: Test code
  script:
    - cd $ROS_VERSION/
    - source /opt/ros/$ROS_CODENAME/local_setup.bash && source install/local_setup.bash && colcon test --event-handlers console_direct+
    - colcon test-result --verbose

noetic:test:
  dependencies:
    - noetic:build
  needs: ["noetic:build"]
  extends:
    - .only_on_ros1_changes
    - .base_tester

foxy:test:
  dependencies:
    - foxy:build
  needs: ["foxy:build"]
  extends:
    - .only_on_ros2_changes
    - .base_tester

#######################
# C++ static analysis #
#######################
# Run C++ static analysis. This is dependent on the `compile_commands.json` file that is
# produced by the build stage. This runs when a C++ file has been changed or if the
# static analysis configuration has changed. Currently, only clang-tidy is executed in
# this stage. More information on clang-tidy can be found on https://clang.llvm.org/extra/clang-tidy/
.clang_tidy_base:
  stage: Static analysis on code
  image: $CI_REGISTRY_IMAGE/$ROS_CODENAME:$TAG
  script:
    - cd $ROS_VERSION/
    # Find all C and C++ related files, filter all files that are not part of the march code
    # and run clang-tidy on the files
    - find src -name '*.hpp' -or -name '*.h' -or -name '*.cpp' -or -name "*.c" | grep -v "src/libraries" | grep -v "xsens" | xargs -L1 -P$(getconf _NPROCESSORS_ONLN) -I{} -- clang-tidy -p build {} 2> /dev/null
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - $DOCKER_FILE
      variables:
        TAG: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'
      when: never
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - $DOCKER_FILE
      variables:
        TAG: $CI_COMMIT_BRANCH
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_COMMIT_BRANCH'
      changes:
        - "$ROS_VERSION/**/*.{hpp,h,cpp,c}"
        - "$ROS_VERSION/**/CMakeLists.txt"
        - ".clang-tidy"
      variables:
        TAG: $CI_DEFAULT_BRANCH

noetic:clang-tidy:
  variables:
    ROS_VERSION: "ros1"
    ROS_CODENAME: "noetic"
    DOCKER_FILE: $ROS1_DOCKERFILE
  dependencies:
    - noetic:build
  needs: ["noetic:build"]
  extends:
    - .clang_tidy_base

foxy:clang-tidy:
  variables:
    ROS_VERSION: "ros2"
    ROS_CODENAME: "foxy"
    DOCKER_FILE: $ROS2_DOCKERFILE
  dependencies:
    - foxy:build
  needs: ["foxy:build"]
  extends:
    - .clang_tidy_base
